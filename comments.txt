It's important to note that the component will re-render any time the value returned from useSelector
changes to a new reference. Components should always try to select the smallest possible amount of data
they need from the store, which will help ensure that it only renders when it actually needs to.

===

If an action needs to contain a unique ID or some other random value, always generate that first and put
it in the action object. Reducers should never calculate random values, because that makes the results
unpredictable.

===

But, what if you want to have async logic interact with the store by dispatching or checking the current store state?
That's where Redux middleware come in. They extend the store, and allow you to:

- Execute extra logic when any action is dispatched (such as logging the action and state)
- Pause, modify, delay, replace, or halt dispatched actions
- Write extra code that has access to dispatch and getState
- Teach dispatch how to accept other values besides plain action objects, such as functions and promises,
  by intercepting them and dispatching real action objects instead

===

The word "thunk" is a programming term that means "a piece of code that does some delayed work".